<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" type="text/css" media="screen" href="/assets/css/style.css?v=">

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The ISLa Language Specification | The Input Specification Language ISLa</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="The ISLa Language Specification" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="ISLa is a language and solver for checking and generation based on context-sensitive constraints of structured inputs." />
<meta property="og:description" content="ISLa is a language and solver for checking and generation based on context-sensitive constraints of structured inputs." />
<link rel="canonical" href="http://localhost:4000/islaspec/" />
<meta property="og:url" content="http://localhost:4000/islaspec/" />
<meta property="og:site_name" content="The Input Specification Language ISLa" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The ISLa Language Specification" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"ISLa is a language and solver for checking and generation based on context-sensitive constraints of structured inputs.","headline":"The ISLa Language Specification","url":"http://localhost:4000/islaspec/"}</script>
<!-- End Jekyll SEO tag -->

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          

          <h1 id="project_title">The Input Specification Language ISLa</h1>
          <h2 id="project_tagline">ISLa is a language and solver for checking and generation based on context-sensitive constraints of structured inputs.</h2>

          
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1 id="the-isla-language-specification">The ISLa Language Specification</h1>

<p>The Input Specification Language (ISLa) is a notation for formally specifying
context-sensitive properties of strings structured by a context-free grammar.
The purpose of this document is to precisely specify ISLa’s syntax and
semantics.</p>

<p>The ISLa version considered in this document is ISLa
<a href="https://github.com/rindPHI/isla/tree/v0.8.16">0.8.16</a>. Please consult the <a href="https://github.com/rindPHI/isla/blob/main/CHANGELOG.md">ISLa
CHANGELOG</a> to find out
if there were recent additions.</p>

<h2 id="table-of-contents"><a href="#toc">Table of Contents</a></h2>

<!-- vim-markdown-toc GFM -->

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#syntax">Syntax</a>
    <ul>
      <li><a href="#grammars">Grammars</a></li>
      <li><a href="#lexer-rules">Lexer Rules</a></li>
      <li><a href="#parser-rules">Parser Rules</a></li>
      <li><a href="#match-expression-lexer-rules">Match Expression Lexer Rules</a></li>
      <li><a href="#match-expression-parser-rules">Match Expression Parser Rules</a></li>
    </ul>
  </li>
  <li><a href="#simplified-syntax">Simplified Syntax</a>
    <ul>
      <li><a href="#simplified-syntax-by-example">Simplified Syntax by Example</a></li>
      <li><a href="#generalized-smt-lib-syntax">Generalized SMT-LIB syntax</a></li>
      <li><a href="#omission-of-in-start">Omission of <code class="language-plaintext highlighter-rouge">in start</code></a></li>
      <li><a href="#omission-of-bound-variable-names">Omission of Bound Variable Names</a></li>
      <li><a href="#free-nonterminals">Free Nonterminals</a></li>
      <li><a href="#x-path-expressions">X-Path Expressions</a></li>
    </ul>
  </li>
  <li><a href="#semantics">Semantics</a>
    <ul>
      <li><a href="#atoms">Atoms</a>
        <ul>
          <li><a href="#smt-lib-expressions">SMT-LIB Expressions</a></li>
          <li><a href="#structural-predicates">Structural Predicates</a></li>
          <li><a href="#semantic-predicates">Semantic Predicates</a></li>
        </ul>
      </li>
      <li><a href="#propositional-combinators">Propositional Combinators</a></li>
      <li><a href="#quantifiers">Quantifiers</a>
        <ul>
          <li><a href="#tree-quantifiers">Tree Quantifiers</a>
            <ul>
              <li><a href="#tree-quantifiers-without-match-expressions">Tree Quantifiers without Match Expressions</a></li>
              <li><a href="#tree-quantifiers-with-match-expressions">Tree Quantifiers with Match Expressions</a></li>
            </ul>
          </li>
          <li><a href="#numeric-quantifiers">Numeric Quantifiers</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#footnotes">Footnotes</a></li>
</ul>

<!-- vim-markdown-toc -->

<h2 id="introduction"><a href="#introduction">Introduction</a></h2>

<p>Strings are the basic datatype for software testing and debugging at the system
level: All programs inputs and outputs are strings, or can be straightforwardly
represented as such. In parsing and fuzzing, Context-Free Grammars (CFGs) are a
popular formalism to decompose unstructured strings of data.</p>

<p>Consider, for example, a simple language of assignments such as <code class="language-plaintext highlighter-rouge">x := 1 ; y :=
x</code>. The following grammar, here presented in <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended Backus–Naur Form
(EBNF)</a>, can be
used to parse and produce syntactically valid assignment programs:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stmt  = assgn, { " ; ", stmt } ;
assgn = var, " := ", rhs ;
rhs   = var | digit ;
var   = "a" | "b" | "c" | ... ;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
</code></pre></div></div>

<p>Using this grammar, the input <code class="language-plaintext highlighter-rouge">x := 1 ; y := x</code> can be parsed into the following
tree structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stmt
├─ assgn
│  ├─ var
│  │  └─ "x"
│  ├─ " := "
│  └─ rhs
│     └─ digit
│        └─ "1"
├─ " ; "
└─ stmt
   └─ assgn
      ├─ var
      │  └─ "y"
      ├─ " := "
      └─ rhs
         └─ var
            └─ "x"
</code></pre></div></div>

<p>In the context of parsing, such trees are called “parse trees;” in the fuzzing
domain, the notion “derivation tree” is preferred. In this document, we will use
the term “derivation tree.”</p>

<p>We call labels of the inner nodes of derivation trees such as <code class="language-plaintext highlighter-rouge">stmt</code> that have
to be further <em>expanded</em> to produce or parse a string “nonterminal elements” or
simply “nonterminals;” consequently, the leaves of the tree are labeled with
“terminal elements” or “terminals.” From a tree, we obtain a string by chaining
the terminals in the order in which they are visited in a depth-first traversal
of the tree. CFGs map nonterminals to one or more <em>expansion alternatives</em> or,
simply, <em>expansions.</em> When using a grammar for fuzzing, we can expand a
nonterminal using any alternative. During parsing, we have to find the right
alternative for the given input (that is, <em>one</em> right alternative, since CFGs
can be <em>ambiguous</em>).</p>

<p>CFGs allow decomposing strings into their elements. However, they are—by
definition—too coarse to capture <em>context-sensitive</em> language features. In
the case of our assignment language, <code class="language-plaintext highlighter-rouge">x := 1 ; y := z</code> is not considered a valid
element of the language, since the identifier <code class="language-plaintext highlighter-rouge">z</code> has not been assigned before
(such that its value is <code class="language-plaintext highlighter-rouge">undefined</code>). Similarly, the program <code class="language-plaintext highlighter-rouge">x := x</code> is
“illegal.” This property, that all right-hand side variables must have been
assigned in a previous assignment, could, in principle, be expressed in a less
restricted grammar. Examples are context-sensitive or even unrestricted
grammars, where left-hand sides can contain additional context in addition to a
single nonterminal value. However, such grammars are tedious to use in
specification, and we do not know any parsing or fuzzing tool based on more
general grammar formalisms.</p>

<p>Enter ISLa. ISLa specifications are based on a <em>reference grammar.</em> The
nonterminals of that grammar determine the vocabulary of the grammar. They take
the roles of variables in unit-level specification languages like
<a href="https://www.cs.ucf.edu/~leavens/JML/jmlrefman/jmlrefman.html">JML</a>. The
following ISLa constraint restricts the language of the reference grammar shown
above to exactly those assignment programs using only previously assigned
variables as right-hand sides:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;assgn&gt; assgn:
  exists &lt;assgn&gt; decl: (
    before(decl, assgn) and 
    assgn.&lt;rhs&gt;.&lt;var&gt; = decl.&lt;var&gt;
  )
</code></pre></div></div>

<p>In ISLa language, nonterminals are surrounded by angular brackets (see also the
<a href="#grammars">section on grammars</a>). The above constraint specifies that</p>

<ul>
  <li><strong>for all</strong> <code class="language-plaintext highlighter-rouge">&lt;assgn&gt;</code> elements that have a <code class="language-plaintext highlighter-rouge">&lt;var&gt;</code> right-hand side (to
satisfy the <code class="language-plaintext highlighter-rouge">assgn.&lt;rhs&gt;.&lt;var&gt;</code>) and which we refer to with the name <code class="language-plaintext highlighter-rouge">assgn</code>,</li>
  <li>there has to <strong>exist</strong> an <code class="language-plaintext highlighter-rouge">&lt;assgn&gt;</code> element that we will call <code class="language-plaintext highlighter-rouge">decl</code>,</li>
  <li>such that <code class="language-plaintext highlighter-rouge">decl</code> appears <strong>before</strong> <code class="language-plaintext highlighter-rouge">assgn</code> in the input <strong>and</strong></li>
  <li>the variable in the right-hand side of <code class="language-plaintext highlighter-rouge">assgn</code> equals the variable in <code class="language-plaintext highlighter-rouge">decl</code>.</li>
</ul>

<p>Note that the <code class="language-plaintext highlighter-rouge">.</code> syntax allows accessing <em>immediate</em> children of elements in
the parse tree; <code class="language-plaintext highlighter-rouge">decl.&lt;var&gt;</code> thus uniquely identifies the left-hand side of an
assignment (since variables in right-hand sides appear as a child of a <code class="language-plaintext highlighter-rouge">&lt;rhs&gt;</code>
nonterminal).</p>

<p>In the remainder of this document, we specify the <a href="#syntax">syntax</a> and
<a href="#semantics">semantics</a> of ISLa formulas.</p>

<h2 id="syntax"><a href="#syntax">Syntax</a></h2>

<p>In this section, we describe the <a href="#grammars">syntax of ISLa’s reference
grammars</a> and the syntax of ISLa formulas themselves. We introduce
the ISLa syntax on a high level by providing grammars in
<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a>. In the
<a href="#semantics">section on ISLa’s semantics</a>, we discuss the individual ISLa syntax
elements in more details and explain their meaning formally and based on
examples.</p>

<h3 id="grammars"><a href="#grammars">Grammars</a></h3>

<p>ISLa’s uses simple CFGs as reference grammars, i.e., without repetition etc.
Valid ISLa grammars are exactly those that can be expressed in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur Form
(BNF)</a>.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>The EBNF grammar for the concrete syntax of ISLa reference grammars looks as
follows, where <code class="language-plaintext highlighter-rouge">NO_ANGLE_BRACKET</code> represents any character but <code class="language-plaintext highlighter-rouge">&lt;</code> and <code class="language-plaintext highlighter-rouge">&gt;</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bnf_grammar = derivation_rule, { derivation_rule } ;

derivation_rule = NONTERMINAL, "::=", alternative, { "|", alternative } ;

alternative = ( STRING | NONTERMINAL ) { STRING | NONTERMINAL } ;

NONTERMINAL = "&lt;", NO_ANGLE_BRACKET, { NO_ANGLE_BRACKET }, "&gt;" ;

STRING = '"' { ESC|. }? '"';
ESC = '\\' ("b" | "t" | "n" | "r" | '"' | "\\") ;
</code></pre></div></div>

<p>Here’s how our example grammar from the <a href="#introduction">introduction</a> looks in
this format (we abbreviated the definition of <code class="language-plaintext highlighter-rouge">&lt;var&gt;</code>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;start&gt; ::= &lt;stmt&gt;
&lt;stmt&gt; ::= &lt;assgn&gt; | &lt;assgn&gt; " ; " &lt;stmt&gt;
&lt;assgn&gt; ::= &lt;var&gt; " := " &lt;rhs&gt;
&lt;rhs&gt; ::= &lt;var&gt; | &lt;digit&gt;
&lt;var&gt; ::= "a" | "b" | "c" | ...
&lt;digit&gt; ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
</code></pre></div></div>

<h3 id="lexer-rules"><a href="#lexer-rules">Lexer Rules</a></h3>

<p>ISLa’s lexer grammar is shown below. In addition to the rules shown, ISLa knows
Python-style line comments starting with <code class="language-plaintext highlighter-rouge">#</code>. These comments as well as
whitespace between tokens are ignored during lexing. The only string delimiter
known to ISLa are double quotes <code class="language-plaintext highlighter-rouge">"</code>. Inside strings, double quotes are escaped
using a backslash character: <code class="language-plaintext highlighter-rouge">\"</code>. Most notably, this also holds for <a href="#smt-lib-expressions">SMT-LIB
expressions</a>, which is a deviation from the SMT-LIB
standard where quotes are escaped by doubling them. In standard SMT-LIB, a
quotation mark inside double quotes is expressed (<code class="language-plaintext highlighter-rouge">""""</code>), whereas in ISLa, one
writes <code class="language-plaintext highlighter-rouge">"\""</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AND = "and" ;
OR = "or" ;
NOT = "not" ;

XOR = "xor" ;
IMPLIES_SMT = "=&gt;" ;
IMPLIES_ISLA = "implies" ;

SMT_INFIX_RE_STR =
      "re.++"
    | "str.++"
    | "str.&lt;="
    ;

SMT_NONBINARY_OP =
      ABS
    | "re.+"
    | "re.*"
    | "str.len"
    | "str.in_re"
    | "str.to_re"
    | "re.none"
    | "re.all"
    | "re.allchar"
    | "str.at"
    | "str.substr"
    | "str.prefixof"
    | "str.suffixof"
    | "str.contains"
    | "str.indexof"
    | "str.replace"
    | "str.replace_all"
    | "str.replace_re"
    | "str.replace_re_all"
    | "re.comp"
    | "re.diff"
    | "re.opt"
    | "re.range"
    | "re.loop"
    | "str.is_digit"
    | "str.to_code"
    | "str.from_code"
    | "str.to.int"
    | "str.from_int"
    ;

XPATHEXPR = (ID | VAR_TYPE), XPATHSEGMENT, { XPATHSEGMENT } ;

XPATHSEGMENT =
      DOT, VAR_TYPE
    | DOT, VAR_TYPE, BROP, INT, BRCL
    | TWODOTS, VAR_TYPE
    ;

VAR_TYPE  = LT, ID, GT ;

DIV = "div" ;
MOD = "mod" ;
ABS = "abs" ;

STRING = '"', { ESC | . }?, '"';
ID = ID_LETTER, { ID_LETTER | DIGIT } ;
INT  = DIGIT, { DIGIT } ;
ESC  = "\\", ( "b" | "t" | "n" | "r" | '"' | "\\" ) ;

DOT  = "." ;
TWODOTS  = ".." ;
BROP  = "[" ;
BRCL  = "]" ;

MUL = "*" ;
PLUS = "+" ;
MINUS = "-" ;
GEQ = "&gt;=" ;
LEQ = "&lt;=" ;
GT = "&gt;" ;
LT = "&lt;" ;

ID_LETTER  = "a".."z" | "A".."Z" | "_" | "\\" | "-" | "." | "^" ;
DIGIT  = "0".."9" ;
</code></pre></div></div>

<h3 id="parser-rules"><a href="#parser-rules">Parser Rules</a></h3>

<p>Below, you find ISLa’s parser grammar. <a href="#smt-lib-expressions">SMT-LIB
expressions</a> are usually expressed in a Lisp-like
S-expression syntax, e.g., <code class="language-plaintext highlighter-rouge">(= x (+ y 13))</code>. This is fully supported by ISLa,
and is robust to extensions in the SMT-LIB format as long as new function
symbols can be parsed as alphanumeric identifiers. Our <a href="#generalized-smt-lib-syntax">prefix and infix syntax
that we added on top of S-expressions</a>, as well as
expressions using operators with special characters, are only parsed correctly
if the operators appear in the <a href="#lexer-rules">lexer grammar</a>. This is primarily
to distinguish expressions in prefix syntax (<code class="language-plaintext highlighter-rouge">op(arg1, arg1, ...)</code>) from
<a href="#strucural-predicates">structural</a> and <a href="#semantic-predicates">semantic
predicates</a>. In future versions of the grammar, we might
relax this constraint.</p>

<p>The <em>top-level constant declaration</em> <code class="language-plaintext highlighter-rouge">const my_const: &lt;my_type&gt;;</code> is optional.
We default to <code class="language-plaintext highlighter-rouge">const start: &lt;start&gt;;</code>. Consequently, if no top-level constant is
provided, the start symbol of the <a href="#grammars">reference grammar</a> must be
<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code> and all <a href="#tree-quantifiers">quantified formulas</a> without an explicit
<code class="language-plaintext highlighter-rouge">in ...</code> specification <a href="#omission-of-in-start">address elements <code class="language-plaintext highlighter-rouge">in start</code></a>.</p>

<p>Match expressions (see the section on <a href="#quantifiers">quantifiers</a>) are hidden
inside the underspecified nonterminal <code class="language-plaintext highlighter-rouge">MATCH_EXPR</code>. We describe the
<a href="#match-expression-lexer-rules">lexer</a> and
<a href="#match-expression-parser-rules">parser</a> grammars for match expressions further
below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>isla_formula = [ const_decl ], formula;

const_decl = "const", ID, ":", VAR_TYPE, ";" ;

formula =
    "forall", VAR_TYPE, [ ID ],                  [ "in" (ID | VAR_TYPE) ], ":", formula
  | "exists", VAR_TYPE, [ ID ],                  [ "in" (ID | VAR_TYPE) ], ":", formula
  | "forall", VAR_TYPE, [ ID ], "=", MATCH_EXPR, [ "in" (ID | VAR_TYPE) ], ":", formula
  | "exists", VAR_TYPE, [ ID ], "=", MATCH_EXPR, [ "in" (ID | VAR_TYPE) ], ":", formula
  | "exists", "int", ID, ":", formula
  | "forall", "int", ID, ":", formula
  | "not", formula
  | formula, AND, formula
  | formula, OR, formula
  | formula, XOR, formula
  | formula, IMPLIES_ISLA, formula
  | formula, "iff", formula
  | ID, "(", predicate_arg, { ",", predicate_arg }, ")"
  | "(", formula, ")"
  | sexpr
  ;

sexpr =
    "true"
  | "false"
  | INT
  | ID
  | XPATHEXPR
  | VAR_TYPE
  | STRING
  | SMT_NONBINARY_OP 
  | smt_binary_op
  | SMT_NONBINARY_OP, "(", [ sexpr, { "," sexpr } ], ")"
  | sexpr, SMT_INFIX_RE_STR, sexpr
  | sexpr, ( PLUS | MINUS ), sexpr
  | sexpr, ( MUL | DIV | MOD ), sexpr
  | sexpr, ( "=" | GEQ | LEQ | GT | LT ), sexpr
  | "(", sexpr, sexpr, { sexpr }, ")"
  ;

predicate_arg = ID | VAR_TYPE | INT | STRING | XPATHEXPR ;


smt_binary_op:
  '=' | GEQ | LEQ | GT | LT | MUL | DIV | MOD | PLUS | MINUS | SMT_INFIX_RE_STR | AND | OR | IMPLIES_SMT | XOR ;
</code></pre></div></div>

<h3 id="match-expression-lexer-rules"><a href="#match-expression-lexer-rules">Match Expression Lexer Rules</a></h3>

<p>We show the actual ANTLR rules of the match expression lexer, since they use
ANTLR “modes” to parse variable declarations and optional match expression
elements into tokens. For details on match expressions, we refer to the <a href="#quantifiers">section
on quantifiers</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BRAOP : '{' -&gt; pushMode(VAR_DECL) ;

OPTOP : '[' -&gt; pushMode(OPTIONAL) ;

TEXT : (~ [{[]) + ;

NL : '\n' + -&gt; skip ;

mode VAR_DECL;
BRACL : '}' -&gt; popMode ;
ID: ID_LETTER (ID_LETTER | DIGIT) * ;
fragment ID_LETTER : 'a'..'z'|'A'..'Z' | [_\-.] ;
fragment DIGIT : '0'..'9' ;
GT: '&gt;' ;
LT: '&lt;' ;
WS : [ \t\n\r]+ -&gt; skip ;

mode OPTIONAL;
OPTCL : ']' -&gt; popMode ;
OPTTXT : (~ ']') + ;
</code></pre></div></div>

<h3 id="match-expression-parser-rules"><a href="#match-expression-parser-rules">Match Expression Parser Rules</a></h3>

<p>The parser rules for match expressions are depicted below in the EBNF format.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>matchExpr = matchExprElement, { matchExprElement } ;

matchExprElement =
    BRAOP, varType, ID, BRACL
  | OPTOP, OPTTXT, OPTCL
  | TEXT
  ;

varType : LT ID GT ;
</code></pre></div></div>

<h2 id="simplified-syntax"><a href="#simplified-syntax">Simplified Syntax</a></h2>

<p><a href="https://github.com/rindPHI/isla/blob/v0.3/CHANGELOG.md">ISLa 0.3</a> added a
simplified syntax layer allowing to specify ISLa constraints much more concisely
in many cases. Furthermore, <a href="#smt-lib-expressions">SMT-LIB expressions</a> can be
expressed in the more common prefix or infix instead of S-expression syntax. All
the additions described in this section are “syntactic sugar;” they are
<em>translated to core ISLa</em> during parsing. In the <a href="#semantics">semantics</a>
section, we thus exclusively focus on “core ISLa” (with explicit variable names,
without “free nonterminals” and XPath expressions, etc.), assuming that all
features described in this section are translated to that language core as
described here.</p>

<h3 id="simplified-syntax-by-example"><a href="#simplified-syntax-by-example">Simplified Syntax by Example</a></h3>

<p>Before we describe the syntactic additions one by one, we demonstrate most of
them along the example of the assignment language from the
<a href="#introduction">introduction</a>. The definition-use constraint discussed there is
expressed as follows in core ISLa:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;assgn&gt; assgn="&lt;var&gt; := {&lt;var&gt; rhs}" in start:
  exists &lt;assgn&gt; decl="{&lt;var&gt; lhs} := &lt;rhs&gt;" in start: (
    before(decl, assgn) and 
    (= lhs rhs)
  )
</code></pre></div></div>

<p>As a first simplification step, we can remove the <code class="language-plaintext highlighter-rouge">in start</code>, which is the
default (since <code class="language-plaintext highlighter-rouge">start</code> is the default “global” constant; cf. the explanations in
the <a href="#semantics">semantics</a> section):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;assgn&gt; assgn="&lt;var&gt; := {&lt;var&gt; rhs}":
  exists &lt;assgn&gt; decl="{&lt;var&gt; lhs} := &lt;rhs&gt;": (
    before(decl, assgn) and 
    (= lhs rhs)
  )
</code></pre></div></div>

<p>Binary SMT-LIB expressions can be written in infix syntax:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;assgn&gt; assgn="&lt;var&gt; := {&lt;var&gt; rhs}":
  exists &lt;assgn&gt; decl="{&lt;var&gt; lhs} := &lt;rhs&gt;": (
    before(decl, assgn) and 
    lhs = rhs
  )
</code></pre></div></div>

<p>While match expressions such as <code class="language-plaintext highlighter-rouge">"&lt;var&gt; := {&lt;var&gt; rhs}"</code> permit a lot of
flexibility for pattern matching and binding variables in subtrees, it is often
easier (but subject to individual taste) to use ISLa’s “XPath” syntax. This
syntax allows addressing children of variables using a dot notation. It is
inspired by the <a href="https://www.w3.org/TR/1999/REC-xpath-19991116/#path-abbrev">XPath abbreviated
syntax</a>, but uses
dots <code class="language-plaintext highlighter-rouge">.</code> instead of slashes <code class="language-plaintext highlighter-rouge">/</code>. Our assignment language constraint can be
equivalently expressed as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;assgn&gt; assgn:
  exists &lt;assgn&gt; decl: (
    before(decl, assgn) and 
    assgn.&lt;rhs&gt;.&lt;var&gt; = decl.&lt;var&gt;
  )
</code></pre></div></div>

<p>Finally, we can omit the universal quantifiers, and instead use its <em>nonterminal
symbol</em> in the quantified formula. Such “free nonterminals” are during parsing
replaced by a new variable bound by an added top-level universal quantifier.
Thus, the most concise formulation of the definition-use constraint is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exists &lt;assgn&gt; decl: (
  before(decl, &lt;assgn&gt;) and 
  &lt;assgn&gt;.&lt;rhs&gt;.&lt;var&gt; = decl.&lt;var&gt;
)
</code></pre></div></div>

<h3 id="generalized-smt-lib-syntax"><a href="#generalized-smt-lib-syntax">Generalized SMT-LIB syntax</a></h3>

<p>At the core of ISLa are SMT-LIB expressions; quantifiers and predicate formulas
are are constructed around those. In the <a href="https://smtlib.cs.uiowa.edu/language.shtml">SMT-LIB
language</a>, all expressions are
written in the S-expression format <code class="language-plaintext highlighter-rouge">(op arg1 arg2)</code> known from languages like
LISP and Scheme. In addition to this syntax, ISLa supports the prefix notation
<code class="language-plaintext highlighter-rouge">op(arg1, arg2)</code> more commonly used in mathematics and programming languages
and, for binary operators, the infix notation <code class="language-plaintext highlighter-rouge">arg1 op arg2</code>. Thus, one may
write</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>17 + str.to.int(y) = str.to.int(x)
</code></pre></div></div>

<p>instead of</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(= (+ 17 (str.to.int y)) (str.to.int x))
</code></pre></div></div>

<p>in ISLa. When parsing an ISLa formula, all such prefix and infix expressions are
translated to S-expressions, which is why S-expressions are printed when
unparsing a formula, regardless of whether you used the generalized syntax to
specify the formula originally or not.</p>

<p><strong>Name conflicts with ISLa predicates.</strong> To distinguish SMT-LIB expressions in
prefix syntax from ISLa predicates, the ISLa parser checks whether the provided
operator is an SMT-LIB function. If so, the expression is parsed as an SMT-LIB
expression. This implies that if an operator name is used both in an SMT-LIB
theory and for an ISLa predicate, the SMT-LIB operator always “wins;” it will
not be possible to parse the predicate. Thus, name clashes with SMT-LIB
operators should be avoided when defining a new ISla predicate.</p>

<h3 id="omission-of-in-start"><a href="#omission-of-in-start">Omission of <code class="language-plaintext highlighter-rouge">in start</code></a></h3>

<p>Let <code class="language-plaintext highlighter-rouge">const my_const: &lt;my_type&gt;; formula</code> be an ISLa specification; if the
<code class="language-plaintext highlighter-rouge">const</code> declaration is omitted, we assume a specification <code class="language-plaintext highlighter-rouge">const start: &lt;start&gt;;</code>
as a default. Then, all subformulas <code class="language-plaintext highlighter-rouge">forall &lt;type&gt; name:</code> and <code class="language-plaintext highlighter-rouge">exists &lt;type&gt;
name:</code> in <code class="language-plaintext highlighter-rouge">formula</code> (where <a href="#omission-of-bound-variable-names">the <code class="language-plaintext highlighter-rouge">name</code> part is
optional</a>) are translated to <code class="language-plaintext highlighter-rouge">forall &lt;type&gt;
name in start:</code> and <code class="language-plaintext highlighter-rouge">exists &lt;type&gt; name in start:</code> during parsing.</p>

<h3 id="omission-of-bound-variable-names"><a href="#omission-of-bound-variable-names">Omission of Bound Variable Names</a></h3>

<p>ISLa permits the omission of a name for the bound variable in quantifiers. In
that case, the nonterminal type of the bound variable may be used to address
that variable, as in</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exists &lt;assgn&gt;: &lt;assgn&gt; = "x := y"
</code></pre></div></div>

<p>Formulas of this or similar shape translate to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exists &lt;assgn&gt; assgn in start: (= assgn "x := y")
</code></pre></div></div>

<p>More formally, in all formulas <code class="language-plaintext highlighter-rouge">Q &lt;type&gt; in v: formula</code>, where <code class="language-plaintext highlighter-rouge">Q</code> is <code class="language-plaintext highlighter-rouge">forall</code>
or <code class="language-plaintext highlighter-rouge">exists</code>, we choose a “fresh” variable name <code class="language-plaintext highlighter-rouge">name</code> and replace the formula 
<code class="language-plaintext highlighter-rouge">Q &lt;type&gt; name in v: formula'</code>,
where <code class="language-plaintext highlighter-rouge">formula'</code> results from <code class="language-plaintext highlighter-rouge">formula</code> by replacing all occurrences of <code class="language-plaintext highlighter-rouge">&lt;typ&gt;</code>
appearing at places where a variable may appear <code class="language-plaintext highlighter-rouge">name</code>. Fresh means that the
name <code class="language-plaintext highlighter-rouge">name</code> is not used anywhere in that formula.</p>

<h3 id="free-nonterminals"><a href="#free-nonterminals">Free Nonterminals</a></h3>

<p>In an ISLa formula, you can use a nonterminal from the reference grammar at
every position where a variable may occur, also if that nonterminal <a href="#omission-of-bound-variable-names">is not
bound by a quantifier</a>. Those nonterminals
represent <em>universally bound variables.</em> A formula <code class="language-plaintext highlighter-rouge">formula</code> with at least one
unbound occurrence of a nonterminal symbol <code class="language-plaintext highlighter-rouge">&lt;type&gt;</code> is turned into a formula
<code class="language-plaintext highlighter-rouge">forall &lt;type&gt; name in start: formula'</code>, where</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">name</code> is a fresh variable name not occurring in <code class="language-plaintext highlighter-rouge">formula</code>, and</li>
  <li><code class="language-plaintext highlighter-rouge">formula'</code> results from <code class="language-plaintext highlighter-rouge">formula</code> by replacing all the <code class="language-plaintext highlighter-rouge">&lt;type&gt;</code> occurrences by
<code class="language-plaintext highlighter-rouge">name</code>,</li>
  <li><code class="language-plaintext highlighter-rouge">start</code> is the constant specified in the <code class="language-plaintext highlighter-rouge">const</code> part of an ISLa
specification, or <code class="language-plaintext highlighter-rouge">start</code> if no such specification is given.</li>
</ul>

<h3 id="x-path-expressions"><a href="#x-path-expressions">X-Path Expressions</a></h3>

<p>As an alternative to <a href="#tree-quantifiers-with-match-expressions">match
expressions</a>, ISLa supports accessing
derivation tree children using a notation inspired by the <a href="https://www.w3.org/TR/1999/REC-xpath-19991116/#path-abbrev">XPath abbreviated
syntax</a>. In
particular, it supports the “child” and “descendant” axes, i.e., referring
direct children and “deeper” descendants of those. In contrast to the original
XPath syntax, we use dots <code class="language-plaintext highlighter-rouge">.</code> instead of slashes <code class="language-plaintext highlighter-rouge">/</code>. We still use the term
“XPath expression” to refer to such expressions.</p>

<p>At any position in an ISLa formula where a variable may occur, one may
alternatively use an XPath expression. An XPath expression in ISLa consists of
one ore more <em>segments</em> of the form <code class="language-plaintext highlighter-rouge">var.&lt;type1&gt;[pos1].&lt;type2&gt;[pos2]</code> (for the
first segment) or <code class="language-plaintext highlighter-rouge">&lt;type&gt;.&lt;type1&gt;[pos1].&lt;type2&gt;[pos2]</code> (for the second and later
segments). Note that the second form can also be used when specifying an ISLa
constraint, but is translated to the first form by <a href="#free-nonterminals">universally closing over the
free nonterminal <code class="language-plaintext highlighter-rouge">&lt;type&gt;</code></a>. Segments are connected using the
<code class="language-plaintext highlighter-rouge">..</code> operator (descendent axis). Each segment consists of one of more child
axis usages connected by <code class="language-plaintext highlighter-rouge">.</code>. The <code class="language-plaintext highlighter-rouge">[pos]</code> specifiers are optional and default to
<code class="language-plaintext highlighter-rouge">[1]</code>.</p>

<p>Semantically, <code class="language-plaintext highlighter-rouge">var.&lt;type1&gt;[pos1]</code> refers to the <code class="language-plaintext highlighter-rouge">pos1</code>-th <em>direct</em> child of type
<code class="language-plaintext highlighter-rouge">&lt;type1&gt;</code> in the derivation tree associated to <code class="language-plaintext highlighter-rouge">var</code>, where counting starts from
1; <code class="language-plaintext highlighter-rouge">var.&lt;type1&gt;[pos1].&lt;type2&gt;[pos2]</code> to the <code class="language-plaintext highlighter-rouge">pos2</code>-th child of type <code class="language-plaintext highlighter-rouge">&lt;type2&gt;</code> of
<em>that</em> element, and so on.</p>

<p>Using the descendent axis, we can address derivation tree children at a greater
distance (than 1). The exact distance cannot be specified. An XPath expression
<code class="language-plaintext highlighter-rouge">var.&lt;type1&gt;[pos1]..&lt;type2&gt;.&lt;type3&gt;[pos3]</code> refers to</p>

<ul>
  <li>the <code class="language-plaintext highlighter-rouge">pos3</code>-th <em>direct</em> child with type <code class="language-plaintext highlighter-rouge">&lt;type3&gt;</code></li>
  <li>of <em>all</em> <code class="language-plaintext highlighter-rouge">&lt;type2&gt;</code> elements that are (indirect) children</li>
  <li>of the <code class="language-plaintext highlighter-rouge">pos1</code>-th <em>direct</em> child with type <code class="language-plaintext highlighter-rouge">&lt;type1&gt;</code></li>
  <li>of the derivation tree associated with <code class="language-plaintext highlighter-rouge">var</code>.</li>
</ul>

<p>An simple example for the use of the <code class="language-plaintext highlighter-rouge">..</code> axis is the formula</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>checksum(&lt;header&gt;, &lt;header&gt;..&lt;checksum&gt;)
</code></pre></div></div>

<p>It specifies that a <code class="language-plaintext highlighter-rouge">checksum</code> predicate should hold for a <code class="language-plaintext highlighter-rouge">&lt;header&gt;</code> element
and all <code class="language-plaintext highlighter-rouge">&lt;checksum&gt;</code> elements somewhere below <code class="language-plaintext highlighter-rouge">&lt;header&gt;</code>.</p>

<p><strong>Translation of XPath expressions.</strong> During parsing, XPath segments are
translated into match expressions. If more than one possible such translation is
possible, we build a conjunction (for universal formulas) or disjunction (for
existential formulas). We illustrate this along the example of an XML
constraint. The example is based on the following grammar:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;start&gt; ::= &lt;xml-tree&gt;
&lt;xml-tree&gt; ::=   &lt;text&gt; 
               | &lt;xml-open-tag&gt; &lt;xml-tree&gt; &lt;xml-close-tag&gt; 
               | &lt;xml-tree&gt; &lt;xml-tree&gt;
&lt;xml-open-tag&gt; ::= "&lt;" &lt;id&gt; "&gt;" | "&lt;" &lt;id&gt; " " &lt;xml-attribute&gt; "&gt;"
&lt;xml-close-tag&gt; ::= "&lt;/" &lt;id&gt; "&gt;"
&lt;xml-attribute&gt; ::= &lt;id&gt; "=" &lt;id&gt; | &lt;xml-attribute&gt; " " &lt;xml-attribute&gt;
&lt;id&gt; ::= &lt;LETTER&gt; | &lt;id&gt; &lt;LETTER&gt;
&lt;text&gt; ::= &lt;text&gt; &lt;LETTER_SPACE&gt; | &lt;LETTER_SPACE&gt;
&lt;LETTER&gt; ::= "a" | "b" | "c" | ... | "0" | "1" | ... | "\"" | "'" | "."
&lt;LETTER_SPACE&gt; ::= "a" | "b" | "c" | ... | "\"" | "'" | " " | "\t"
</code></pre></div></div>

<p>Now, consider the constraint <code class="language-plaintext highlighter-rouge">&lt;xml-open-tag&gt;.&lt;id&gt; = "a"</code> specifying that
identifiers in opening tags should equal the letter <code class="language-plaintext highlighter-rouge">a</code>. First, we introduce a
new variable for <code class="language-plaintext highlighter-rouge">&lt;xml-open-tag&gt;</code> which we bind in a universal quantifier (as
described in the section on <a href="#free-nonterminals">free nonterminals</a>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;xml-open-tag&gt; optag in start: optag.&lt;id&gt; = "a"
</code></pre></div></div>

<p>Next, we search the reference grammar for expansions of <code class="language-plaintext highlighter-rouge">&lt;xml-open-tag&gt;</code>
containing at least one <code class="language-plaintext highlighter-rouge">&lt;id&gt;</code> nonterminal, which are both expansions for that
nonterminal. Thus, we create a match expression for both of these alternative,
and obtain the following conjunction of two quantified formulas:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;xml-open-tag&gt; optag="&lt;{&lt;id&gt; id}&gt;" in start: id = "a" and
forall &lt;xml-open-tag&gt; optag="&lt;{&lt;id&gt; id} &lt;xml-attribute&gt;&gt;" in start: id = "a"
</code></pre></div></div>

<p>We can also allow longer identifiers, but restrict the allowed letters to “a.”
This can be concisely expressed with the descendant axis <code class="language-plaintext highlighter-rouge">..</code>:
<code class="language-plaintext highlighter-rouge">&lt;xml-open-tag&gt;.&lt;id&gt;..&lt;LETTER&gt; = "a"</code>. When translating this formula to core
ISLa, we start from the outside and obtain</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;xml-open-tag&gt; optag="&lt;{&lt;id&gt; id}&gt;" in start: id..&lt;LETTER&gt; = "a" and
forall &lt;xml-open-tag&gt; optag="&lt;{&lt;id&gt; id} &lt;xml-attribute&gt;&gt;" in start: id..&lt;LETTER&gt; = "a"
</code></pre></div></div>

<p>Next, we “eliminate” the first XPath segment by introducing a universal
quantifier inside the already added one:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;xml-open-tag&gt; optag="&lt;{&lt;id&gt; id}&gt;" in start: 
  forall &lt;LETTER&gt; letter in id:
    letter = "a" and
forall &lt;xml-open-tag&gt; optag="&lt;{&lt;id&gt; id} &lt;xml-attribute&gt;&gt;" in start:
  forall &lt;LETTER&gt; letter in id:
    letter = "a"
</code></pre></div></div>

<p>In summary,</p>

<ul>
  <li>Individual XPath segments are translated to match expressions. The child axis
<code class="language-plaintext highlighter-rouge">.</code> allows addressing <em>direct</em> children of a nonterminal that appear in at
least one expansion alternative. If more than one occurrence of a nonterminal
symbol appear in the same expansion alternative, indices <code class="language-plaintext highlighter-rouge">&lt;type&gt;[idx]</code> can be
use to choose the one to constrain.</li>
  <li>For each segment chain consisting of more than one segment, we eliminate the
segments from left to right by introducing universal quantifiers.</li>
  <li>XPath expressions <em>do not add expressiveness</em> to ISLa: They are translated to
match expressions and quantifiers during parsing.</li>
</ul>

<h2 id="semantics"><a href="#semantics">Semantics</a></h2>

<p>In this section, we discuss ISLa’s <em>semantics</em>, i.e., what an ISLa specification
<em>means</em>. Clearly, there has to be a relation between ISLa formulas and strings,
since ISLa is a specification language for strings.  However, it is more
convenient to define the semantics of an ISLa formula as the set of <em>derivation
trees</em> it represents.</p>

<p>On a high level, we define the semantics of a context-free grammar as the set of
derivation trees that can be (transitively) derived from its start symbol. In
the subsequent sections, we define (for each ISLa syntax element) a relation
\(t\models{}\varphi\) that holds if, and only if, the derivation tree \(t\)
<em>satisfies</em> the ISLa formula \(\varphi\). Finally, the semantics of an ISLa
formula \(\varphi\) are all derivation trees represented by the reference
grammar that satisfy \(\varphi\).</p>

<p>The <em>language</em> of CFGs, i.e., the strings they represent, is thoroughly defined
in the standard literature.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> We follow the same style. We assume a relation
\(t\Rightarrow{}t’\) between derivation trees that holds if \(t’\) can be
<em>derived</em> from \(t\) by adding to some leaf node in \(t\) labeled with a
nonterminal symbol \(n\) new children nodes corresponding to some expansion
alternative for \(n\). For example, consider the following derivation tree:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;stmt&gt;
├─ &lt;assgn&gt;
│  ├─ &lt;var&gt;
│  │  └─ "x"
│  ├─ " := "
│  └─ &lt;rhs&gt;
│     └─ &lt;digit&gt;
│        └─ "1"
├─ " ; "
└─ &lt;stmt&gt;
</code></pre></div></div>

<p>Using the expansion alternative <code class="language-plaintext highlighter-rouge">&lt;stmt&gt; ::= &lt;assgn&gt;</code> from the <a href="#grammars">(BNF) grammar for
our assignment language</a>, we can expand the open <code class="language-plaintext highlighter-rouge">&lt;stmt&gt;</code> node by
adding an <code class="language-plaintext highlighter-rouge">&lt;assgn&gt;</code> child. The result looks as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;stmt&gt;
├─ &lt;assgn&gt;
│  ├─ &lt;var&gt;
│  │  └─ "x"
│  ├─ " := "
│  └─ &lt;rhs&gt;
│     └─ &lt;digit&gt;
│        └─ "1"
├─ " ; "
└─ &lt;stmt&gt;
   └─ &lt;assgn&gt;
</code></pre></div></div>

<p>This is not the only option: We can also expand <code class="language-plaintext highlighter-rouge">&lt;stmt&gt;</code> with the expansion
alternative <code class="language-plaintext highlighter-rouge">&lt;stmt&gt; ::= &lt;assgn&gt; " ; " &lt;stmt&gt;</code>, which results in</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;stmt&gt;
├─ &lt;assgn&gt;
│  ├─ &lt;var&gt;
│  │  └─ "x"
│  ├─ " := "
│  └─ &lt;rhs&gt;
│     └─ &lt;digit&gt;
│        └─ "1"
├─ " ; "
└─ &lt;stmt&gt;
   ├─ &lt;assgn&gt;
   ├─ " ; "
   └─ &lt;stmt&gt;
</code></pre></div></div>

<p>If \(t\) is the initial tree and \(t_1\) and \(t_2\) are the two
expansions, then both \(t\Rightarrow{}t_1\) and \(t\Rightarrow{}t_2\) hold.
Now, let \(\Rightarrow^\star\) be the reflexive and transitive closure of
\(\Rightarrow\). Then, the set of derivation trees \(T(G)\) represented by a
CFG \(G\) is defined as \(T(G):=\{t\,\vert\,t_0\Rightarrow^\star{}t\}\),
where \(t_0\) is a derivation tree consisting only of the grammar’s start
symbol.</p>

<p>Assuming the relation \(\models\) has been defined, we define the semantics
\([\![\varphi]\!]\) of an ISLa formula \(\varphi\) as
\([\![\varphi]\!]:=\{t\in{}T(G)\,\vert\,t\models\varphi\wedge\mathit{closed}(t)\}\), 
where \(G\) is the reference grammar for \(\varphi\) and
the predicate \(\mathit{closed}\) holds for all derivation trees whose leaves
are labeled with <em>terminals</em>.</p>

<p>In the remaining parts of this section, we discuss each element of the ISLa
syntax and define the relation \(\models\) along the way.</p>

<p>When doing so, we also need (and define step by step) a function
\(\mathit{freeVars}(\varphi)\) that returns the <em>free variables</em> of a formula
\(\varphi\). Those are the variables that are not bound by a
<a href="#quantifiers">quantifier</a>.</p>

<p>In ISLa, all variables are of “string” sort. This is especially important when
writing <a href="#smt-lib-expressions">SMT-LIB expressions</a>, since appropriate
conversions have to be added when, e.g., comparing a variable <em>representing</em> an
integer to an actual integer.</p>

<p>To define \(\models\) for formulas with free variables, we use an additional
<em>variable assignment</em> \(\beta\) associating variables with derivation trees.
We write \(\beta\models\varphi\) to express that \(\varphi\) holds when
instantiating free variables in \(\varphi\) according to the assignments in
\(\beta\).</p>

<p>The notation \(t\models\varphi\) used above, where \(t\) is a derivation
tree, is a <em>shortcut</em>. When specifying an ISLa formula, we can declare a <em>global
constant</em> using the syntax <code class="language-plaintext highlighter-rouge">const constant_name: &lt;constant_type&gt;;</code> (cf. the
<a href="#parser-rules">ISLa grammar</a>). The declaration is optional; if it is not
present, a constant <code class="language-plaintext highlighter-rouge">start</code> of type <code class="language-plaintext highlighter-rouge">&lt;start&gt;</code> will be assumed. Assuming <code class="language-plaintext highlighter-rouge">c</code> is
this constant, then \(t\models\varphi\) is</p>

<ul>
  <li><em>undefined</em> if \(\mathit{freeVars}(\varphi)\neq\{c\}\).</li>
  <li>equivalent to \([c\mapsto{}t]\models\varphi\), where \([c\mapsto{}t]\) is a variable
assignment mapping \(c\) to \(t\).</li>
</ul>

<h3 id="atoms"><a href="#atoms">Atoms</a></h3>

<p>The name ISLa has a double meaning: First, it is an acronym for “Input
specification language;” and second, “isla” is the Spanish word for “island.”
The reason for this second meaning is that ISLa embeds the <a href="https://smtlib.cs.uiowa.edu/">SMT-LIB
language</a> as an <em>island language.</em> Around this
embedded language, ISLa essentially adds quantifiers aware of the structure of
context-free grammars. Thus, SMT-LIB expressions are the heart and the most
important <em>atomic</em> ISLa formulas. Atomic means that they do not contain
additional ISLa subformulas. ISLa also knows another type of atomic formula:
<em>predicate formulas.</em> Here, we distinguish <em>structural</em> and <em>semantic</em>
predicates. Structural predicates allow addressing structural relations such as
“before” of “inside;” semantic predicates complement SMT-LIB and allow
expressing complex constraints that are out of reach of the SMT-LIB language.
This section address all three types of ISLa atoms.</p>

<h4 id="smt-lib-expressions"><a href="#smt-lib-expressions">SMT-LIB Expressions</a></h4>

<p>ISLa embeds the SMT-LIB language. Since all ISLa variables are strings, the
<a href="https://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml">SMT-LIB string
theory</a> is the most
relevant theory in the ISLa context. The function <code class="language-plaintext highlighter-rouge">str.to.int</code><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> converts
strings to integers, such that integer operations using the <a href="https://smtlib.cs.uiowa.edu/theories-Ints.shtml">integer
theory</a> are possible. A typical
SMT-LIB ISLa constraint (inspired by our <a href="https://www.fuzzingbook.org/beta/html/FuzzingWithConstraints.html">ISLa
tutorial</a>) is
<code class="language-plaintext highlighter-rouge">(&gt;= (str.to.int pagesize) 100)</code>. For this to work, all derivation trees that
can be substituted for the <code class="language-plaintext highlighter-rouge">pagesize</code> variable have to be <em>positive</em> integers
(cf. the response by Z3’s lead developer Nikolaj Bjorner in <a href="https://github.com/Z3Prover/z3/issues/1846#issuecomment-424809364">this GitHub
issue</a>).
SMT-LIB uses a Lisp-like S-expression syntax. We abstain from discussing this
syntax here and instead refer to the <a href="https://smtlib.cs.uiowa.edu/language.shtml">SMT-LIB
documentation</a>.</p>

<p><strong>Free variables.</strong> The set \(freeVars(\varphi)\) for an SMT-LIB expression
\(\varphi\) consists of all symbols not part of the <a href="https://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2021-05-12.pdf">SMT-LIB
language</a>
and not contained in one of the (built-in) <a href="https://smtlib.cs.uiowa.edu/theories.shtml">SMT-LIB
theories</a>, in particular the
<a href="https://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml">integer</a> and
<a href="https://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml">string</a> theories.</p>

<p>We assume a function \(\mathit{sat}\) mapping an SMT-LIB formula (expression
of Boolean type) to the values \(\mathit{SAT}\), \(\mathit{UNSAT}\), or
\(\mathit{UNDEFINED}\). \(\mathit{SAT}\) means that there exists a variable
assignment for which the formula holds. A returned \(\mathit{UNSAT}\) value
implies that there does not exist any such an assignment. Furthermore, the
\(\mathit{UNDEFINED}\) value is issued if no definitive decision could be made
(e.g., due to a timeout or a prover insufficiency). We will not define
\(\mathit{sat}\) formally in this document, since it is no original
contribution of ISLa. The ISLa solver implements \(\mathit{sat}\) by calling
the <a href="https://github.com/Z3Prover/z3">Z3 theorem prover</a>.</p>

<p><strong>Semantics.</strong> Let \(\beta\) be a variable assignment and \(\varphi\) an
SMT-LIB formula.  Furthermore, let \(\varphi’\) be a formula resulting from
<em>negating</em> the <em>instantiation</em> of \(\varphi\) according to \(\beta\). Then,
\(\beta\models\varphi\) holds if, and only if,
\(\mathit{sat}(\varphi’)=\mathit{UNSAT}\). When instantiating \(\varphi\),
we have to convert the derivation trees in \(\beta\) to strings first, since
SMT and Z3 do not know derivation trees.</p>

<h4 id="structural-predicates"><a href="#strucural-predicates">Structural Predicates</a></h4>

<p>Consider the assignment language from <a href="#introduction">the introduction</a>. The
relevant semantic property for this language is that for each right-hand side
variable, there has to exist a <em>preceding</em> assignment to that variable. SMT-LIB
expressions are insufficient for expressing such structural relations because
they are unaware of grammatical structure. In simple cases, we could in
principle express them using string functions (e.g., comparing indices). Too
many such constraints, however, often result in solver timeouts. More
complex use cases (e.g., some element has to occur <em>inside</em> or as the <em>n-th
child</em> of another one) can even be impossible to express using SMT-LIB alone. To
that end, ISLa introduces so-called <em>structural predicates</em>. These predicates
mostly reason about the relative positions of elements in a parse tree. An
example is the <code class="language-plaintext highlighter-rouge">before</code> predicate used for the assignment language example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall &lt;assgn&gt; assgn:
  exists &lt;assgn&gt; decl: (
    before(decl, assgn) and 
    assgn.&lt;rhs&gt;.&lt;var&gt; = decl.&lt;var&gt;
  )
</code></pre></div></div>

<p>This predicate accepts two variables as arguments, and holds if, and only if,
the first argument occurs earlier in the <em>reference tree</em> than the second one.
The reference tree is the instantiation of the global constant (implicitly)
declared in an ISLa specification. Structural predicates might also accept
string literals as arguments. For example, <code class="language-plaintext highlighter-rouge">level("GE", "&lt;block&gt;", decl, expr)</code>,
inspired by the definition-use constraint of a C-like language, expresses that
the declaration <code class="language-plaintext highlighter-rouge">decl</code> has to occur at the same or a greater <code class="language-plaintext highlighter-rouge">&lt;block&gt;</code> level
than <code class="language-plaintext highlighter-rouge">expr</code>, as in <code class="language-plaintext highlighter-rouge">{int x; {int y = x;}}</code>, where <code class="language-plaintext highlighter-rouge">expr</code>
would be the <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">int y = x;</code> and <code class="language-plaintext highlighter-rouge">decl</code> the <code class="language-plaintext highlighter-rouge">int x;</code> declaration. The
program <code class="language-plaintext highlighter-rouge">{{int x;} int y = x;}</code> would not satisfy this constraint.</p>

<p>In the following table, we informally describe the meaning of the ISLa built-in
structural predicates.</p>

<table>
  <thead>
    <tr>
      <th>Predicate</th>
      <th>Intuitive Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">after(node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> occurs after <code class="language-plaintext highlighter-rouge">node_2</code> (not below) in the parse tree.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">before(node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> occurs before <code class="language-plaintext highlighter-rouge">node_2</code> (not below) in the parse tree.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">consecutive(node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> and <code class="language-plaintext highlighter-rouge">node_2</code> are consecutive leaves in the parse tree.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">different_position(node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> and <code class="language-plaintext highlighter-rouge">node_2</code> occur at different positions (cannot be the same node).</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">direct_child(node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> is a direct child of <code class="language-plaintext highlighter-rouge">node_2</code> in the derivation tree.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">inside(node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> is a subtree of <code class="language-plaintext highlighter-rouge">node_2</code>.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">level(PRED, NONTERMINAL, node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> and <code class="language-plaintext highlighter-rouge">node_2</code> are related relatively to each other as specified by <code class="language-plaintext highlighter-rouge">PRED</code> and <code class="language-plaintext highlighter-rouge">NONTERMINAL</code> (see below). <code class="language-plaintext highlighter-rouge">PRED</code> and <code class="language-plaintext highlighter-rouge">NONTERMINAL</code> are Strings.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">nth(N, node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> is the <code class="language-plaintext highlighter-rouge">N</code>-th occurrence of a node with its nonterminal symbol within <code class="language-plaintext highlighter-rouge">node_2</code>. <code class="language-plaintext highlighter-rouge">N</code> is a numeric String.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">same_position(node_1, node_2)</code></td>
      <td><code class="language-plaintext highlighter-rouge">node_1</code> and <code class="language-plaintext highlighter-rouge">node_2</code> occur at the same position (have to be the same node).</td>
    </tr>
  </tbody>
</table>

<p><strong>Free variables.</strong> All structural predicate atoms \(\varphi\) are of the form
\(\mathit{pred}(a_1,a_2,\dots,a_n)\). The free variables
\(\mathit{free_vars}(\varphi)\) of \(\varphi\) consists of all those
\(a_i\) that are not string literals.</p>

<p><strong>Semantics.</strong> To evaluate structural predicates, we need to access elements in
the derivation tree assigned to the global ISLa constant \(c\) in the variable
assignment \(\beta\). Thus, we assume that we know \(c\).<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> The semantics
of structural predicate atoms can only be defined for each predicate
individually. Below, we demonstrate this along the example of <code class="language-plaintext highlighter-rouge">before</code>.</p>

<p><strong>Semantics of <code class="language-plaintext highlighter-rouge">before</code>.</strong> Since <code class="language-plaintext highlighter-rouge">before</code> reasons about <em>relative positions</em> of
derivation trees, we need to encode these positions. To that end, we introduce
the notion of <em>paths</em> in derivation trees. A path is a (potentially empty) tuple
of natural numbers \((n_1,n_2,\dots,n_2)\). In a tree \(t\), the empty path
\(()\) points to the tree itself, the path \((n)\) to the \(n\)-th child
of \(t\)’s root, the path \((n,m)\) to the \(m\)-th child of the
\(n\)-th child of the root, and so on. Counting start from 0, so \((0)\) is
the path of the root’s first child. Below, we indicate the paths of each subtree
in the derivation tree from the <a href="#introduction">introduction</a>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;stmt&gt;                 &lt;- ()
├─ &lt;assgn&gt;             &lt;- (0)
│  ├─ &lt;var&gt;            &lt;- (0,0)
│  │  └─ "x"           &lt;- (0,0,0)
│  ├─ " := "           &lt;- (0,1)
│  └─ &lt;rhs&gt;            &lt;- (0,2)
│     └─ &lt;digit&gt;       &lt;- (0,2,0)
│        └─ "1"        &lt;- (0,2,0,0)
├─ " ; "               &lt;- (1)
└─ &lt;stmt&gt;              &lt;- (2)
   └─ &lt;assgn&gt;          &lt;- (2,0)
      ├─ &lt;var&gt;         &lt;- (2,0,0)
      │  └─ "y"        &lt;- (2,0,0,0)
      ├─ " := "        &lt;- (2,0,1)
      └─ &lt;rhs&gt;         &lt;- (2,0,2)
         └─ &lt;var&gt;      &lt;- (2,0,2,0)
            └─ "x"     &lt;- (2,0,2,0,0)
</code></pre></div></div>

<p>The subtree with path \((2,0,2)\) in this tree, for example, is the tree</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;rhs&gt;
└─ &lt;var&gt;
   └─ "x"
</code></pre></div></div>

<p>We assume a partial function \(\mathit{path}(t_1, t_2)\) that returns that
path pointing to \(t_1\) in the tree \(t_2\).<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> The function is defined
if, and only if, \(t_1\) occurs in \(t_1\). For example, if \(t_1\) is the
<code class="language-plaintext highlighter-rouge">&lt;rhs&gt;</code>-tree above and \(t_2\) the <code class="language-plaintext highlighter-rouge">&lt;stmt&gt;</code> tree from which we extracted it, 
\(\mathit{path}(t_1, t_2)=(0,2,0)\).</p>

<p>Let \(\beta\) be a variable assignment, \(c\) the global constant from the
ISLa specification, and \(p_i\) be the paths \(\mathit{path}(t_i, \beta(c))\)
for \(i=1,2\). Now, \(\beta\models\mathit{before}(t_1, t_2)\) holds if, and
only if, the function \(\mathit{isBefore}(p_1, p_2)\) returns \(\top\). We
recursively define \(\mathit{isBefore}\) as follows:</p>

\[\mathit{isBefore}(p_1, p_2) =
\begin{cases}
  \bot                                              &amp; \text{if } p_1 = () \text{ or } p_2 = () \\
  \bot                                              &amp; \text{if } p_2^1 &lt; p_1^1 \\
  \top                                              &amp; \text{if } p_1^1 &lt; p_2^1 \\
  isBefore((\mathit{tail}(p_1), \mathit{tail}(p_2)) &amp; \text{otherwise}
\end{cases}\]

<p>where \(p^1\) is the first element of the tuple \(p\) and
\(\mathit{tail}(p)\) is the (possibly empty) tuple resulting from removing the
first element of \(p\).</p>

<p>The remaining structural predicates can be defined in a similar fashion. Only
for predicates like <code class="language-plaintext highlighter-rouge">level</code> we additionally need to retrieve labels of subtrees
(grammar symbols) in addition to paths.</p>

<h4 id="semantic-predicates"><a href="#semantic-predicates">Semantic Predicates</a></h4>

<p>Semantic predicates were introduced mainly to compensate shortcomings of SMT-LIB
expressions. A classic example would be a constraint involving a checksum
computation. For example, the <a href="https://en.wikipedia.org/wiki/Tar_(computing)#File_format">checksum for TAR
archives</a> involves
setting the original checksum to spaces, summing up the TAR header, and
converting the results to an octal number. Even if this was expressible in
SMT-LIB, it would probably result in solver timeouts in many cases. When using
semantic predicates in input generation, they not only can evaluate to a Boolean
value, but also change the reference derivation tree. For example, they might
assign the part of the tree corresponding to the checksum value with a tree
representing the correct checksum.</p>

<p>The below table displays the semantic predicates currently supported by ISLa.
For special purposes, it is possible to add dedicated semantic predicates (e.g.,
for checksum computation in binary formats) that must be implemented in Python.</p>

<table>
  <thead>
    <tr>
      <th>Predicate</th>
      <th>Intuitive Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">count(in_tree, NEEDLE, NUM)</code></td>
      <td>There are <code class="language-plaintext highlighter-rouge">NUM</code> occurrences of the <code class="language-plaintext highlighter-rouge">NEEDLE</code> nonterminal in <code class="language-plaintext highlighter-rouge">in_tree</code>. <code class="language-plaintext highlighter-rouge">NEEDLE</code> is a String, <code class="language-plaintext highlighter-rouge">NUM</code> a numeric String or int variable.</td>
    </tr>
  </tbody>
</table>

<p>The currently only standard semantic ISLa predicate is <code class="language-plaintext highlighter-rouge">count</code>. For example,
<code class="language-plaintext highlighter-rouge">count(in_tree, "&lt;line&gt;", "3")</code> holds if, and only if, there exist exactly three
children labeled with the <code class="language-plaintext highlighter-rouge">&lt;line&gt;</code> nonterminal inside the derivation tree
<code class="language-plaintext highlighter-rouge">in_tree</code>. What distinguishes <code class="language-plaintext highlighter-rouge">count</code> from a structural predicate is, e.g., that
it is possible to pass a <em>numeric variable</em> (see the section <a href="#numeric-quantifiers">on numeric
quantifiers</a>) instead of a string literal as the third
argument. Structural predicates could not handle this: Whether the predicate
holds or not would depend on the actual—not present—value of that
variable. The semantic predicate <code class="language-plaintext highlighter-rouge">count</code> can, however, count the <code class="language-plaintext highlighter-rouge">&lt;line&gt;</code>
occurrences in <code class="language-plaintext highlighter-rouge">in_tree</code> and assign the resulting number to the variable.</p>

<p><strong>Free variables and semantics.</strong> For the purpose of defining the semantics of
semantic predicates, we can, however, re-use the definitions from the section on
<a href="#structural-predicates">structural predicates</a>. Since the variable assignment
\(\beta\) must assign values to all variables, there do not occur any
remaining “free” variables in the arguments of a semantic predicates. Thus, also
a semantic predicate atom can either hold or not hold for a given variable
assignment and list of arguments.</p>

<h3 id="propositional-combinators"><a href="#propositional">Propositional Combinators</a></h3>

<p>Propositional combinators allow combining ISLa formulas to more complex
specifications. ISLa supports <code class="language-plaintext highlighter-rouge">not</code>, <code class="language-plaintext highlighter-rouge">and</code>, and <code class="language-plaintext highlighter-rouge">or</code>. Additionally, one can use
the derived combinators <code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">implies</code>, and <code class="language-plaintext highlighter-rouge">iff</code>. The formula <code class="language-plaintext highlighter-rouge">A xor B</code> is
translated to <code class="language-plaintext highlighter-rouge">(A and (not B)) or (B and (not A))</code>; <code class="language-plaintext highlighter-rouge">A implies B</code> is translated
to <code class="language-plaintext highlighter-rouge">(not A) or B</code>; and <code class="language-plaintext highlighter-rouge">A iff B</code> is translated to <code class="language-plaintext highlighter-rouge">(A and B) or ((not A) and
(not B))</code>.</p>

<p>In many cases, we can omit parentheses based on the <em>operator precedence</em> of
propositional combinators. This precedence is specified by the order of the
combinators in the <a href="#parser-rules">ISLa parser grammar</a>. The list of operators
ordered by their binding strength in increasing order is <code class="language-plaintext highlighter-rouge">not</code>, <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code>,
<code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">implies</code>, <code class="language-plaintext highlighter-rouge">iff</code>. Thus, <code class="language-plaintext highlighter-rouge">(A and (not B)) or (B and (not A))</code> (the
encoding of <code class="language-plaintext highlighter-rouge">A xor B</code>) is equivalent to <code class="language-plaintext highlighter-rouge">A and not B or B and not A</code>—we do
not need any parentheses.</p>

<p><strong>Free variables.</strong> For <code class="language-plaintext highlighter-rouge">not</code>, we define
\(\mathit{freeVars}(\mathtt{not}~\varphi):=\mathit{freeVars}(\varphi)\). Let
\(\circ\) be one of the binary propositional combinators and
\(\varphi,\,\psi\) be two ISLa formulas. Then,</p>

\[\mathit{freeVars}(\varphi\circ\psi):=\mathit{freeVars}(\varphi)\cup\mathit{freeVars}(\psi)\]

<p><strong>Semantics.</strong> We define the semantics for <code class="language-plaintext highlighter-rouge">not</code>, <code class="language-plaintext highlighter-rouge">and</code>, and <code class="language-plaintext highlighter-rouge">or</code> as follows:</p>

<ul>
  <li>\(\beta\models\mathtt{not}~\varphi\) holds if, and only if,
\(\beta\models\varphi\) does <em>not</em> hold.</li>
  <li>\(\beta\models\varphi~\mathtt{and}~\psi\) holds if, and only if, 
\(\beta\models\varphi\) and \(\beta\models\psi\) <em>both</em> hold.</li>
  <li>\(\beta\models\varphi~\mathtt{or}~\psi\) holds if, and only if, 
at least one of \(\beta\models\varphi\) <em>or</em> \(\beta\models\psi\) hold.</li>
</ul>

<h3 id="quantifiers"><a href="#quantifiers">Quantifiers</a></h3>

<p>Quantifiers come in two flavors in ISLa. First, we have quantifiers over
derivation trees, e.g., <code class="language-plaintext highlighter-rouge">forall &lt;type&gt; name in tree: ...</code>. In the
<a href="#introduction">introduction</a>, we have shown examples for those. A second type
of quantifier are the quantifiers over <em>integers</em>. They have the form <code class="language-plaintext highlighter-rouge">forall
int name: ...</code> or <code class="language-plaintext highlighter-rouge">exists int name: ...</code>. The variable <code class="language-plaintext highlighter-rouge">name</code> is, as all ISLa
variables, of string sort, but ranges over numeric values.</p>

<h4 id="tree-quantifiers"><a href="#tree-quantifiers">Tree Quantifiers</a></h4>

<p>There are four types of tree quantifiers in ISLa, as universal quantifiers
(<code class="language-plaintext highlighter-rouge">forall</code>) and existential quantifiers (<code class="language-plaintext highlighter-rouge">exists</code>) can come with or without a
specified <em>match expression</em>. We first discuss the semantics of tree quantifiers
without match expressions, and then focus on those with match expressions.</p>

<h5 id="tree-quantifiers-without-match-expressions"><a href="#tree-quantifiers-without-match-expressions">Tree Quantifiers without Match Expressions</a></h5>

<p>Intuitively, a formula <code class="language-plaintext highlighter-rouge">forall &lt;type&gt; name in tree: A</code> is true if A holds <em>for
all</em> subtrees in <code class="language-plaintext highlighter-rouge">tree</code> labeled with <code class="language-plaintext highlighter-rouge">&lt;type&gt;</code>. Conversely, <code class="language-plaintext highlighter-rouge">exists &lt;type&gt; name
in tree: A</code> holds if there is just <em>some</em> such subtree in <code class="language-plaintext highlighter-rouge">tree</code>.</p>

<p><strong>Free variables.</strong> In a quantified tree formula without match expression, the
free variables are the free variables of the formula in the core of the
quantifier as well as the variable after <code class="language-plaintext highlighter-rouge">in</code>; the variable <code class="language-plaintext highlighter-rouge">name</code> is excluded
from this set, since it is <em>bound</em> by the quantifier. Let \(Q\) be either
<code class="language-plaintext highlighter-rouge">forall</code> or <code class="language-plaintext highlighter-rouge">exists</code>. We define</p>

\[\mathit{freeVars}(Q~T~v~\mathtt{in}~\mathit{t}:~\varphi)
:=\left(\mathit{freeVars}(\varphi)\cup\{t\}\right)\setminus\{v\}\]

<p><strong>Semantics.</strong> Let \(\mathit{subtrees}(N, t)\) be the subtrees of the
derivation tree \(t\) labeled with the nonterminal symbol \(N\). Then, we
define the semantics of quantified formulas without match expressions as
follows:</p>

<ul>
  <li>\(\beta\models\mathtt{forall}~T~v~\mathtt{in}~t:\,\varphi\) holds if, and
only if, \(\beta[v\mapsto{}t’]\models\varphi\) holds for all
\(t’\in\mathit{subtrees}(T, \beta(t))\)</li>
  <li>\(\beta\models\mathtt{exists}~T~v~\mathtt{in}~t:\,\varphi\) holds if, and
only if, \(\beta[v\mapsto{}t’]\models\varphi\) holds for some
\(t’\in\mathit{subtrees}(T, \beta(t))\)</li>
</ul>

<p>where \(\beta[v\mapsto{}t’]\) is the variable assignment mapping variable
\(v\) to the derivation tree \(t’\) and all other variables to their mapping
in \(\beta\).</p>

<h5 id="tree-quantifiers-with-match-expressions"><a href="#tree-quantifiers-with-match-expressions">Tree Quantifiers with Match Expressions</a></h5>

<p>A <em>match expression</em> is an abstract word from the language of the reference
grammar. For example, <code class="language-plaintext highlighter-rouge">x := y</code> is a concrete word from our assignment language
(see <a href="#introduction">introduction</a>); <code class="language-plaintext highlighter-rouge">&lt;var&gt; := y</code> would be a valid match
expression. Additionally, match expressions allow binding elements of that
“abstract” word to variables, as in <code class="language-plaintext highlighter-rouge">{&lt;var&gt; myvar} := y</code>. By using match
expressions in quantifiers, we can (1) restrict the possible instantiations of
the bound variable to those that match the match expression, and (2) access
elements of these instantiations by giving them names that can be referred in
the quantified formula.</p>

<p>To increase the flexibility of match expressions, they can contain <em>optional</em>
elements inside square brackets <code class="language-plaintext highlighter-rouge">[...]</code>. Elements inside these optionals cannot
be bound to variables: Only plain terminal and nonterminal symbols may occur
there. For example, <code class="language-plaintext highlighter-rouge">&lt;assgn&gt;[ ; &lt;stmt&gt;]</code> is a possible match expression for a
<code class="language-plaintext highlighter-rouge">&lt;stmt&gt;</code> nonterminal in the assignment language. It matches statements
consisting of a single assignment and one with an assignment followed by a
statement. Match expressions can also go “deeper.” The expression 
<code class="language-plaintext highlighter-rouge">&lt;assgn&gt;[ ; &lt;assgn&gt;]</code> is also a valid match expression for a <code class="language-plaintext highlighter-rouge">&lt;stmt&gt;</code>, matching
any statement consisting of exactly one <em>or</em> two assignments.</p>

<p><strong>Free variables.</strong> For a match expression \(\mathit{mexpr}\), let
\(\mathit{freeVars}(\mathit{mexpr})\) be the variables specified in curly
braces inside \(\mathit{mexpr}\). Let \(Q\) be <code class="language-plaintext highlighter-rouge">forall</code> or <code class="language-plaintext highlighter-rouge">exists</code>. Then,
we define</p>

\[\mathit{freeVars}(Q~T~v\mathtt{=}\text{"$\mathit{mexpr}$"}~\mathtt{in}~\mathit{t}:~\varphi)
:=\left(\mathit{freeVars}(\varphi)\cup\mathit{freeVars}(\mathit{mexpr})\cup\{t\}\right)\setminus\{v\}\]

<p>To define the <em>semantics</em> of quantifiers with match expressions, we parse the
match expression into a set of (typically open, i.e., containing nonterminal
leaves) derivation trees. We can get more than one result: Either because
optionals are used, or because the reference grammar is ambiguous. If the match
expression contains variables, we record the paths from the root of these trees
to the nodes corresponding to the bound elements. Then, we continue as for
<a href="#tree-quantifiers-without-match-expressions">quantified formulas without match
expressions</a>: If <code class="language-plaintext highlighter-rouge">Q &lt;type&gt;
var="mexpr" in tree: A</code> is the formula (<code class="language-plaintext highlighter-rouge">Q</code> being either <code class="language-plaintext highlighter-rouge">forall</code> or <code class="language-plaintext highlighter-rouge">exists</code>),
we collect subtrees from <code class="language-plaintext highlighter-rouge">tree</code> with roots labeled with <code class="language-plaintext highlighter-rouge">&lt;type&gt;</code>. Then, however,
we select only those of which the some derivation tree for the match expression
is a <em>prefix</em>. Then, we instantiate <code class="language-plaintext highlighter-rouge">var</code> and all variables in <code class="language-plaintext highlighter-rouge">mexpr</code> according
to the found match, and check whether <code class="language-plaintext highlighter-rouge">A</code> holds for all/one of these
instantiations.</p>

<p>To make this—slightly—more formal, we “define” a function
\(\mathit{mexprTrees}\) by example.  The result of
\(\mathit{mexprTrees}(T,\mathit{mexpr})\), for a nonterminal symbol \(T\)
match expression \(\mathit{mexpr}\), is a set of pairs \((t,P)\) of (1) a
derivation tree \(t\) corresponding to the parsed match expression, where
\(T\) is used as a start symbol (such that the root of \(t\) is labeled with
\(T\)), and (2) a mapping \(P\) of variables bound in match expressions to
the paths where the corresponding tree elements occur in \(t\).</p>

<p>Consider again the assignment language and let the match expression
\(\mathit{mexpr}\) be <code class="language-plaintext highlighter-rouge">{&lt;var&gt; lhs} := {&lt;var&gt; rhs}[ ; &lt;assgn&gt;]</code>. We visualize
the result of
\(\mathit{mexprTrees}(\mathtt{\langle{}stmt\rangle},\mathit{mexpr})\) by
indicating the mapping \(P\) in the textual representation of the two
resulting derivation trees. The first element of the result set, where the
optional part has been left out, is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stmt
└─ assgn
   ├─ var      lhs ↦ (0,0)
   ├─ " := "
   └─ rhs
      └─ var   rhs ↦ (0,2,0)
</code></pre></div></div>

<p>The second element, which contains the optional second assignment, is</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stmt
├─ assgn
│  ├─ var      lhs ↦ (0,0)
│  ├─ " := "
│  └─ rhs
│     └─ var   rhs ↦ (0,2,0)
├─ " ; "
└─ stmt
   └─ assgn
</code></pre></div></div>

<p>We need a function \(\mathit{match}(t, t’, P)\) taking a derivation tree
\(t\) and a pair \(t’,P\) computed by \(\mathit{mexprTrees}\) and
returning (1) \(\bot\) if \(t’\) does not match \(t\), or otherwise (2) a
<em>variable assignment</em> mapping variables in \(P\) to the corresponding
subtrees in \(t\).</p>

<p>We now recursively define \(\mathit{match}\). Thereby,</p>

<ul>
  <li>\(l(t)\) is the label of the tree \(t\);</li>
  <li>all alternatives in the definition are <em>mutually exclusive</em> (the first
applicable one is applied);</li>
  <li>by \(\mathit{numc}(t)\) we denote the number of  children of the derivation
tree \(t\);</li>
  <li>by \(\mathit{child}(t, i)\) we denote the \(i\)-th child of t, starting
with 1;</li>
  <li>\(P_i\) is computed from a mapping \(P\) from variables to paths by
discarding all paths in \(P\) not starting with \(i\) and taking the
<em>tail</em> (discarding the first element) for all other paths; and</li>
  <li>we use standard set union notation \(\bigcup_{i=1}^n\beta_i\) for combining 
variable assignments \(\beta_i\).</li>
</ul>

\[\mathit{match}(t, t', P) :=
\begin{cases}
\bot                                                                                  &amp; \text{if }l(t)\neq{}l(t')\vee(\mathit{numc}(t')&gt;0\wedge \\
                                                                                      &amp; \qquad\mathit{numc}(t)\neq\mathit{numc}(t')) \\
[v\mapsto{}t]                                                                         &amp; \text{if }P=[v\mapsto{}()]\text{ for some }v \\
\bot                                                                                  &amp; \text{if }\mathit{match}(\mathit{child}(t, i), \mathit{child}(t', i), P_i)=\bot \\
                                                                                      &amp; \qquad\text{for any }i\in[1,\dots,\mathit{numc}(t)] \\
\bigcup_{i=1}^{\mathit{numc}(t)}\Big( &amp; \\
\quad\mathit{match}\big(\mathit{child}(t, i),                  &amp; \\
\quad\hphantom{\mathit{match}\big(}\mathit{child}(t', i), P_i\big)\Big) &amp; \text{otherwise} \\
\end{cases}\]

<p>Based on \(match\) and \(mexprTrees\), we can now define the semantics of
quantified formulas with match expressions.</p>

<ul>
  <li>\(\beta\models\mathtt{forall}~T~v\mathtt{=}\text{“$\mathit{mexpr}$”}~\mathtt{in}~t:\,\varphi\)
holds if, and only if,
    <ul>
      <li><strong>for all</strong> \(t_1\in\mathit{subtrees}(T, \beta(t))\) and</li>
      <li><strong>for all</strong> \((t_2,P) \in \mathit{mexprTrees}(T, \mathit{mexpr})\), it holds that</li>
      <li>\(\mathit{match}(t_1, t_2, P)\neq\bot\) <strong>implies that</strong></li>
      <li>\(\beta[v\mapsto{}t_1]\cup\mathit{match}(t_1, t_2, P)\models\varphi\).</li>
    </ul>
  </li>
  <li>\(\beta\models\mathtt{exists}~T~v\mathtt{=}\text{“$\mathit{mexpr}$”}~\mathtt{in}~t:\,\varphi\)
holds if, and only if,
    <ul>
      <li><strong>there is a</strong> \(t_1\in\mathit{subtrees}(T, \beta(t))\) and</li>
      <li><strong>there is a</strong> \((t_2,P) \in \mathit{mexprTrees}(T, \mathit{mexpr})\) such that</li>
      <li>\(\mathit{match}(t_1, t_2, P)\neq\bot\) <strong>and</strong></li>
      <li>\(\beta[v\mapsto{}t_1]\cup\mathit{match}(t_1, t_2, P)\models\varphi\).</li>
    </ul>
  </li>
</ul>

<h4 id="numeric-quantifiers"><a href="#numeric-quantifiers">Numeric Quantifiers</a></h4>

<p>Numeric quantifiers are of the form <code class="language-plaintext highlighter-rouge">forall int var; A</code> or <code class="language-plaintext highlighter-rouge">exists int var; A</code>.
They allow introducing a fresh variable, unconnected to the reference grammar,
ranging over strings representing <em>positive</em> integers. We only allow positive
integers since the SMT solver used by ISLa, Z3, does not support converting
converting negative numeric strings to integers and back (see <a href="https://github.com/Z3Prover/z3/issues/1846#issuecomment-424809364">this GitHub
issue</a>). The
main use case of numeric quantifiers is connecting several semantic predicates.
Consider, for example, the following ISLa constraint for CSV files:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exists int colno: (
  str.to.int(colno) &gt;= 3 and 
  str.to.int(colno) &lt;= 5 and 
  count(&lt;csv-header&gt;, "&lt;column&gt;", colno) and 
  forall &lt;csv-record&gt; line:
    count(line, "&lt;column&gt;", colno))
</code></pre></div></div>

<p>This constraint expresses that the number of columns in the <code class="language-plaintext highlighter-rouge">&lt;csv-header&gt;</code> field
of a CSV header is between 3 and 5, and that all lines after the header have to
share the same number of columns. If it was possible to express the <code class="language-plaintext highlighter-rouge">count</code>
predicate using pure SMT-LIB expressions, we could have expressed this
constraint without semantic predicates and, consequently, without the
existential integer quantifier by forming an equation of the number of columns
in the header and the number of columns in each line.</p>

<p>The <code class="language-plaintext highlighter-rouge">forall int</code> quantifier expresses that a property has to hold <em>for all</em>
possible positive integers. In our experience, it is not often used in practice.
However, if we wanted to <em>negate</em> the above property for CSV files, the result
would contain such a quantifier.</p>

<p><strong>Free variables.</strong> The free variables set is computed similarly as for <a href="#tree-quantifiers">tree
quantifiers</a>. Let \(Q\) be <code class="language-plaintext highlighter-rouge">forall</code> or <code class="language-plaintext highlighter-rouge">exists</code>. We define</p>

\[\mathit{freeVars}(Q~\mathtt{int}~v:~\varphi):=\mathit{freeVars}(\varphi)\setminus\{v\}\]

<p><strong>Semantics.</strong> Let \(N\) be the set of all derivation trees whose string
representation correspond to that of a positive integer, e.g., “0”, 1”, “17”,
etc. We define the semantics of quantified integer formulas as follows:</p>

<ul>
  <li>\(\beta\models\mathtt{forall~int}~v:\,\varphi\) holds if, and
only if, \(\beta[v\mapsto{}n]\models\varphi\) holds for all
\(n\in{}N\)</li>
  <li>\(\beta\models\mathtt{exists~int}~v:\,\varphi\) holds if, and
only if, \(\beta[v\mapsto{}n]\models\varphi\) holds for some
\(n\in{}N\)</li>
</ul>

<h2 id="footnotes"><a href="#footnotes">Footnotes</a></h2>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>From <a href="https://github.com/rindPHI/isla/blob/v0.8.14/CHANGELOG.md">ISLa 0.8.14</a> on, the <code class="language-plaintext highlighter-rouge">ISLaSolver</code> and the <code class="language-plaintext highlighter-rouge">evaluate</code> function both accept grammars in concrete syntax in addition to the Python dictionary format of the <a href="https://www.fuzzingbook.org/html/Grammars.html">Fuzzing Book</a>. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>For example, 	John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman: <em>Introduction to Automata Theory, Languages, and Computation, 3rd Edition</em>. Pearson international edition, Addison-Wesley 2007, ISBN 978-0-321-47617-3. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>In the SMT-LIB standard, this function is called <code class="language-plaintext highlighter-rouge">str.to_int</code>. ISLa, however, uses the Z3 SMT solver, where the corresponding function has the name <code class="language-plaintext highlighter-rouge">str.to.int</code>. Obviously, <a href="https://stackoverflow.com/questions/46524843/missing-str-to-int-s-in-z3-4-5-1#answer-46528332">Z3 supported <code class="language-plaintext highlighter-rouge">str.to.int</code> before <code class="language-plaintext highlighter-rouge">str.to_int</code> became an official standard</a>. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>In the ISLa implementation, we distinguish two types (in the sense of object-oriented classes) of variables: <em>bound variables</em> (bound by <a href="#quantifiers">quantifiers</a>) and <em>constants</em>. Thus, we can always extract reference trees from variable assignments. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>In the ISLa system, derivation trees have unique identifiers, such that we can distinguish trees with identical structure. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="/assets/mathjax/tex-chtml.js"></script>
